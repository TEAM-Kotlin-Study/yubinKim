# [ Kotlin Study📱] Week 2: 4장 코틀린
## 기본구문
### 변수와 상수
- 변수는 var, 상수는 val로 선언.
### 함수
- fun 함수명(인수1: 자료형, 인수2 : 자료형 ...): 반환자료형
- ⚠️ 함수는 좀 더 일반적이며 모든 메서드는 함수이다! 개념 혼동 주의 ⚠️
## 기본자료형
### 숫자형
- Double 
- Float 
- Long 
- int 
- Short 
- Byte
### 문자형
- String *여러줄 표현시에는 """ """*
- Char
### 배열
- Arrays 라는 병도의 타입으로 표현함. 
- arrayOf()메서드를 사용하여 배열의 생성과 초기화를 함께 수행.
## 제어문
### if
- 자바와 동일
### when
- 자바의 switch문에 대응.
### for
- 자바의 foreach 문과 비슷함.
### while
- while 문과 do while문 모두 자바와 동일.
## 클래스
### 클래스 선언
- 자바와 다르게 new 키워드로 객체 생성하지 않음
### 생성자
- 초기화 코드를 작성하기 위해 constructor로 생성자 표현, 블록에 코드를 작성.
- init 블록에 자성한 코드가 클래스를 인스턴스화할 때 가장 먼저 초기화됨.
### 프로퍼티
- 자바와 다르게 게터 세터 메서드 없이 바로 점을 찍고 프로퍼티에 접근 가능.
- 코틀린은 프로퍼티가 게터 세터를 대체
### 접근 제한자
- public : 전체공개. 기본적으로 public 
- private : 현재 파일 내부에서만 사용 가능
- internal : 같은 모둘내에서만 사용 가능
- protacted : 상속받은 클래스에서 사용 가능
### 클래스의 상속
- 코틀린에서 클래스는 **기본적으로 상속이 금지**됨. 상속을 위해서는 open 키워드를 클래스 선언 앞에 추가하기.
### 내부 클래스
- inner를 사용. 외부클래스에 대한 참조를 가짐.
### 추상 클래스
- 클래스와 미구현 메서드 앞에 abstruct 키워드를 붙임.
- 직접 인스턴스화 할수 없고 다른 클래스가 상속하여 미구현 메서드를 구현해야 함.
### 데이터 클래스
- 클래스 선언앞에 data키워드를 붙이면 구현한 클래스를 간단한게 생성 가능.
### 구조 분해
- 크로퍼티를 순서대로 할당해주는 기법. *(104 페이지 코드 참조)*
## 인터페이스
### 인터페이스의 선언
- 인터페이스에 추상 메서드를 포함 할 수 있다. *(원래는 추상클래스에서 추상 메서드는 abstruct 키워드가 필요하나 생략 가능.)*
- 구현된 메서드 또한 포함 가능. 자바 default 메서드에 대응.
### 인터페이스의 구현
- 미구현 메서드를 작성 시 override 키워드를 메서드 앞에 추가 (run 함수를 오버라이드)
### 상속과 인터페이스를 함께 구현
- 상속은 하나의 클래스만 상속 but, 인터페이스는 콤마로 구분하여 여러 인터페이스 동시에 구현 가능.
## null 가능성
### null 허용?
   - 기본적으로 null값을 허용하지 않음. -> 모든 객체는 생성과 동시에 값을 대입하여 초기화해야 함.
   - null 허용하기 위해서 자료형의 오른쪽에 ?기호를 붙여야함.
### lateinit 키워드로 늦은 초기화
   - 초기화를 나중에 할 떄 lateinit키워드를 변수 선언 앞에 추가하기.
   - 초기화를 잊으면 잘못된 null값을 참조하여 종료될 수 있음
   - var 변수에서만 사용
   - null 값으로 초기화 할 수 없음
   - 초기화 전에는 변수를 사용할 수 없음
   - int, long, Double, Float 에서는 사용할 수 없음
### lazy로 늦은 초기화
   - lateinit이 var로 선언한 변수의 늦은 초기화하면 lazy는 값을 변경할 수 없는 val을 사용할 수 있음.
   - val 선언 뒤에 by lazy블록에 코기화에 필요한 코드 작성.
   - 늦은 초기화를 하면 앱이 시갖될 떄 연산을 분산시킬 수 있어 빠른 실행에 도움이 됨.
   - val 에서만 사용 가능.
### null 값이 아님을 보증(!!)
   - 변수 뒤에 !!를 추가하면 null값이 아님을 보증하게 됨. 
``` kotlin
    val name2: String = name //에러
    val name3: String? = name //ok
```
    
### 안전한 호출(?.)
  - .대신 ?.연산자를 사용해 메서드를 호출하면 null값이 아닌 경우에만 호출
### 엘비스 연산자(?:)
- 안전한 호출 시 null이 아닌 기본값을 반환하고 싶을 때는 엘비스 연산자를 함께 사용.
## 컬렉션
### 리스트
- 배열처럼 같은 자료형의 데이터들을 순서대로 가진 자료구조
- 중복된 아이템 가질 수 있음, 추가, 삭제, 교체등이 쉬움.
### 맵
- 키와 값의 쌍으로 이루어진 키가 중복될 수 없는 자료구조
- 맵의 요소에 접근 시, 대괄호 안에 키를 요소명으로 작성하여 접근
### 집합
- 중복되지 않는 요소들로 구성된 자료구조.
- setOf() : 읽기 전용 집합
- mutableSetOf() : 수정가능한 집합 생성
## 람다식
- 하나의 함수를 표현하는 방법으로 익명 클래스나 익명 함수를 간결하게 표현 할 수 있어서 매우 유용.
- 남발할 경우 가독성이 떨어짐 
``` kotlin
    fun add(x : Int, y: Int): Int {
    return x + y
    }
    //아래와 같이 표현 할 수 있다.
    fun add(x: Int, y: Int) = x + y
    //{인수1: 타입1, 인수2: 타입2 -> 본문}
    var add = { x: Int, y: Int -> x + y}
    
    println(add(2,5) //7
```
### SAM 변환
- 자바로 작성된 메서드가 하나인 인터페이스를 구현할 때 대신 함수를 작성하는 것
- SAM 변환은 자바에서 작성한 인터페이스일때만 동작! (코틀린에서는 인터페이스 대신 함수 사용 지향)
## 기타 기능
- 확장 함수 : 원래있던 클래스에 기능을 추가하는 함수
- 형변환 : 숫자형 자료형끼리 쉽게 형변환 가능
- 형 체크 : 변수의 형이 무엇인지 검사하는 기능
- 고차 함수 : 인자로 함수를 전달하는 기능
- 동반 객체 : 클래스의 인스턴스 생성 없이 사용할 수 있는 객체
- let() 함수 : 블록에 자기 자신을 전당하고 수행된 결과를 변환하는 함수
- with() 함수 : 인자로 객체를 받고 블록에서 수행된 결과를 반환하는 함수
- apply() 함수 : 블록에 자기 자신을 전달하고 이 객체를 반환하는 함수
- run() 함수 : 익명함수처럼 사용하거나, 블록에 자기 자신을 전달하고 수행된 결과를 반환하는 함수
